[TOC]

### 实验1-分析squid父进程和日志子进程之间的管道通信

#### 基本

- 使用`strace`、`ps`、`lsof`，观察启动时、启动后、通信时的管道系统调用
- **RTFM**。



#### 案例

```shell
# 1 查看进程基本关系
divsigma@tom:~/simple-server/examples/framework-intro$ ps -ef | grep squid
root       24982       1  0 00:39 ?        00:00:00 /usr/sbin/squid -sYC
proxy      24984   24982  0 00:39 ?        00:00:00 (squid-1) --kid squid-1 -sYC
proxy      24985   24984  0 00:39 ?        00:00:00 (logfile-daemon) /var/log/squid/access.log
divsigma   25708    5871  0 02:06 pts/2    00:00:00 grep --color=auto squid

# 2 启动telnet访问squid服务，并发送"hello"


# 3 telnet同时strace追踪日志守护进程
## 3.1 启动后，telnet squid服务，read(0,...的阻塞才会停止
divsigma@tom:~/simple-server/examples/framework-intro$ sudo strace -p 24985
strace: Process 24985 attached
read(0, "L1648951600.990      3 192.168.5"..., 4096) = 104
write(3, "1648951600.990      3 192.168.56"..., 101) = 101
## 3.2 用lsof进一步观察fd=0和fd=3是什么文件
### fd=0/1，被重定向到了同一个socket（怀疑是socketpair），而且0是读端
### fd=3，指向输出的日志文件，可以用vi打开，验证确实写入了上面的一行
divsigma@tom:~/simple-server/examples/framework-intro$ sudo lsof -p 24985
COMMAND     PID  USER   FD   TYPE             DEVICE SIZE/OFF   NODE NAME
log_file_ 24985 proxy    0u  unix 0xffff9e3aae889c00      0t0 178856 type=STREAM
log_file_ 24985 proxy    1u  unix 0xffff9e3aae889c00      0t0 178856 type=STREAM
log_file_ 24985 proxy    2u   CHR                1,3      0t0      6 /dev/null
log_file_ 24985 proxy    3w   REG              253,0      205 524295 /var/log/squid/access.log

# 4 telnet同时strace追踪主进程（日志进程的父进程）
divsigma@tom:~$ sudo strace -p 24984
strace: Process 24984 attached
epoll_wait(7, [], 65536, 790)       = 0
epoll_wait(7, [], 65536, 0)         = 0
epoll_wait(7, [{EPOLLIN, {u32=8, u64=8}}], 65536, 999) = 1
read(8, "hello\r\n", 4096)          = 7
getpid()                            = 24984
epoll_ctl(7, EPOLL_CTL_MOD, 8, {EPOLLIN|EPOLLOUT|EPOLLERR|EPOLLHUP, {u32=8, u64=8}}) = 0
epoll_wait(7, [{EPOLLOUT, {u32=8, u64=8}}], 65536, 273) = 1
write(8, "HTTP/1.1 400 Bad Request\r\nServer"..., 3673) = 3673
read(8, 0x7ffe9806b210, 65535)      = -1 EAGAIN (Resource temporarily unavailable)
epoll_ctl(7, EPOLL_CTL_ADD, 10, {EPOLLOUT|EPOLLERR|EPOLLHUP, {u32=10, u64=10}}) = 0
epoll_ctl(7, EPOLL_CTL_DEL, 8, 0x7ffe9807b484) = 0
close(8)                            = 0
epoll_wait(7, [{EPOLLOUT, {u32=10, u64=10}}], 65536, 269) = 1
write(10, "L1648951600.990      3 192.168.5"..., 104) = 104
epoll_wait(7, [{EPOLLOUT, {u32=10, u64=10}}], 65536, 266) = 1
epoll_ctl(7, EPOLL_CTL_DEL, 10, 0x7ffe9807b514) = 0
epoll_wait(7, [], 65536, 265)       = 0
epoll_wait(7, [], 65536, 0)         = 0
## 4.1 用lsof确认fd=7/8/10
### fd=7，是用于epoll_wait的fd；
### fd=10，根据DEVICE的地址和它在10上执行的write内容猜测
###        应该是用于跟子进程（日志进程）进行通信的socketpair写端（地址相差0x400）
### fd=9，不在lsof中，但观察strace输出，可见它是epoll_wait()返回的，而且从8中读取了“hello”，所以
###       8应该是进程用于和telnet通信的socket
divsigma@tom:~$ sudo lsof -p 24984
COMMAND   PID  USER   FD      TYPE             DEVICE SIZE/OFF   NODE NAME
squid   24984 proxy    0u      CHR                1,3      0t0      6 /dev/null
squid   24984 proxy    1u      CHR                1,3      0t0      6 /dev/null
squid   24984 proxy    2u      CHR                1,3      0t0      6 /dev/null
squid   24984 proxy    3u      REG              253,0     2603 524290 /var/log/squid/cache.log.1
squid   24984 proxy    4u      CHR                1,3      0t0      6 /dev/null
squid   24984 proxy    5u     IPv6             178853      0t0    UDP *:41812
squid   24984 proxy    6u     unix 0xffff9e3aae888000      0t0 178825 type=DGRAM
squid   24984 proxy    7u  a_inode               0,14        0  10376 [eventpoll]
squid   24984 proxy    9u     IPv4             178854      0t0    UDP *:59791
squid   24984 proxy   10u     unix 0xffff9e3aae889800      0t0 178855 type=STREAM
```





#### <span style="color:red">思考题</span>

##### Q1：直接`sudo strace service squid start`得到的输出为何找不到`fork`、`24984`和`24985`？如何跟踪squid启动过程中创建子进程和重定向时的系统调用？

描述：如题



#### Q2：`strace -p`实现的基本思路？

描述：系统调用会产生中断信号，strace捕获中断信号？







### 实验2-用POSIX接口共享内存demo

#### 基本

- 进程间通信（IPC）一般有四种方式：管道（常指双工管道）、信号量、消息队列、共享内存。
  - sockpair方式最原始简单，常用于父子进程通信（如实验1和之前的统一事件源）可以`man unix`查看更多（如实验3）
  - 后三种因为是由AT&T System V2版本的UNIX引入，所以统称为System V IPC。
  - <span style="color:red">各自优劣？</span>
- 共享内存针对**IPC**而言，有三种方式：mmap、SystemV的shm接口、POSIX的shm接口
  - <span style="color:red">三者使用方法？机制区别？优劣？</span>
- 可以尝试仿照实验1，用`lsof`和`ipcs`分析父子进程对mmap后文件的持有状态



#### 代码





#### <span style="color:red">思考题</span>

##### Q1：经典问题，线程vs进程？

描述：Linux2.6以前原生不支持线程，POSIX的线程库是怎么管理线程的（即NPTL）？相比进程模拟线程（如LinuxThread），有什么优缺点？

- https://labuladong.gitbook.io/algo-en/v.-common-knowledge/linuxprocess#:~:text=But%20both%20thread%20and%20process,shared%20with%20its%20parent%20process.
- https://www.informit.com/articles/article.aspx?p=370047&seqNum=3#:~:text=To%20the%20Linux%20kernel%2C%20there,certain%20resources%20with%20other%20processes.
- Linux2.6前不支持原生线程，LinuxThread中用`task_struct`管理线程，用clone系统调用并指定CLONE_THREAD创建线程，提供了管理线程，这相当于用进程模拟线程，有什么问题？
- 线程模型：完全用户调度（用户多线程对内核表现为单进程，内核用单线程调度该进程。早期Berkley UNIX采用该模式），完全内核调度（用户N线程映射为内核N线程。NPTL采用该模式），双层调度（N:M）。具体实现可用`getconf GNU_LIBPTHREAD_VERSION`查看。
- 









### 实验3-进程间传递文件描述符

#### 基本

- fd编号是局部的，为什么会有效？详见`man unix`的`SCM_RIGHTS`和`man open`的NOTES
  - 事实上，被传递的是文件描述（或者说文件对象）的引用，接收方会使用一个新的fd编号。文件描述（文件对象）记录了打开文件的各种信息，文件描述符是该对象的引用。
  - 还可以使用`kcmp()`的KCMP_FILE操作比较文件描述是否相等
    - 即可能有0==1！——`kcmp(pid_0, pid_1, KCMP_FILE, 0, 1)==0`
- 



#### 代码

- https://stackoverflow.com/questions/2358684/can-i-share-a-file-descriptor-to-another-process-on-linux-or-are-they-local-to-t



#### <span style="color:red">思考题</span>

##### Q1：关于文件描述符和设备的区别？为什么bash输入命令时看得见，输入password时看不见？如何实现？

描述：使用重定向似乎行不通

- 





### 实验4-子线程fork导致死锁

#### 基本

- 从`man fork`的NOTES中知道

  > Note the following further points:
  >
  > The  child **process is created with a single thread—the one that called fork()**.  The entire virtual address space of the parent is replicated in the child, including the **states of mutexes**, **condition variables, and other pthreads objects**; the use of pthread_atfork(3) may be  helpful  for  dealing with problems that this can cause.

  - 子进程只会从调用fork的线程上fork，所以**子进程是从父进程的main线程fork出来**的。因为**mutex是全局的**，子进程会继承mutex状态
  - 所以要让子进程的main线程进入死锁，就要在父进程的main线程fork之前，启动worker线程并获得锁（父进程在fork前先pthread_create并sleep一会儿），且未释放（worker获得锁后sleep，确保main线程fork时持有锁）。

- 最后状态

  - 子进程的main线程因为继承了父进程的worker线程中锁的状态，所以子进程的main线程死锁了。
  - 父进程的main线程因为wait(NULL)，也在等待
  - 父进程的worker线程不受影响。



#### 代码

- `multithread_fork.cc`

- 输出

  > divsigma@tom:~/simple-server/examples/multitasking$ ./multithread_fork
  > divsigma@tom:~/simple-server/examples/multitasking$ ./multithread_fork
  > [thread-140466592986880] trying to acquire lock
  > [thread-140466592986880] acquired lock
  > [main] waiting ...
  > [process-2780] trying to acquire lock
  > [thread-140466592986880] released lock
  >
  > NO RETURN

- 



#### <span style="color:red">思考题</span>

##### Q1：但`man fork`的DESCRIPTION又说子进程不会继承“process-associatd record locks”，mutex锁属于什么情况？

描述：如题。（为什么`man pthread_mutex_lock`也打不开？——POSIX手册在`manpages-posix-dev`包里）







### 实验5-用单一线程处理进程所有信号

#### 代码

- `signal_thread.cc`



#### <span style="color:red">思考题</span>

##### Q1：为什么`pthread_sigmask(SIG_BLOCK,...)`的信号能被`pthread_create`的线程`sigwait()`到？

描述：看不懂`man pthread_sigmask`的EXAMPLE。

- `man pthread_sigmask` --> `man sigprocmask` --> `man sigwait` --> `man sigwaitinfo`--> `man sigprocmask`--> `man sigwaitinfo`-->...

> **[man pthread_sigmask]**
>
> NOTES
>
> ​	A new thread inherits a copy of its creator's signal mask.
>
> 
>
> **[man sigprocmask]**
>
> SIG_BLOCK
>
> ​	The set of blocked signals is the union of the current set and the set argument.
>
> SIG_UNBLOCK
>               The signals in set are removed from the current set of blocked signals.  It is permissible to attempt to unblock a signal which is not blocked.
>
> ...
>
> NOTES
>
> ​	It is not possible to block SIGKILL or SIGSTOP.  Attempts to do so are silently ignored.
>
> ​	Each of the threads in a process has its own signal mask.
>
> ​	A child created via fork(2) inherits a copy of its parent's signal mask; the signal mask is preserved across execve(2).
>
> 
>
> **[man sigwaitinfo]**
>
> NOTES
>
> In normal usage, the calling program blocks the signals in set via a prior call to sigprocmask(2) (so that the default disposition for  these  signals does  not occur if they become pending between successive calls to sigwaitinfo() or sigtimedwait()) and does not establish handlers for these signals. 
>
> In a **multithreaded** program, the signal should be blocked in all threads, in order to prevent the signal being treated according to its default  disposition in a thread other than the one calling sigwaitinfo() or sigtimedwait()).
>
> The  set  of signals that is pending for a given thread is the union of the set of signals that is pending specifically for that thread and the set of signals that is pending for the process as a whole (see signal(7)).
>
> Attempts to wait for SIGKILL and SIGSTOP are silently ignored.
>
> If **multiple threads** of a process are blocked waiting for the same signal(s) in sigwaitinfo() or sigtimedwait(), then exactly one of the threads will actually receive the signal if it becomes pending for the process as a whole; which of the threads receives the signal is indeterminate.   

- 总之，细品`man`：
  - 每个线程都有自己的信号掩码，而且每个自己BLOCK的信号都有默认处理方式。`sigwait()`就是wait这些BLOCK的信号来**自定义处理**。所以多线程中为了统一BLOCK信号行为，应该先统一BLOCK（缺省各个线程的自定义处理），然后需要处理的线程调用`sigwait()`来处理。
  - 进程的每个线程都有信号掩码，并继承自创建它们的线程的信号掩码。通过`pthread_sigmask(SIG_BLOCK,...)`后的信号一般会调用`sigwait()`进行自定义处理，因为这些信号被掩盖后，默认没有处理函数（SIGKILL和SIGSTOP除外）。为了避免BLOCK的信号被`sigwait()`以外的线程默认处理了，一个进程的多个线程会同时BLOCK这些信号并默认不处理。最终最多只有一个调用了`sigwait()`的线程对BLOCK信号进行处理。



##### Q2：BLOCK==截获？如何查看信号默认处理的行为？





### 实验6/7/8-线程池和进程池相关

（待学习Cpp Primer过程中同步补充）

