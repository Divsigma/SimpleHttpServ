### 实验1-用集中写发送HTTP响应

#### 基本

- Tom在端口`11111`启动`sendfile_service`服务，但不进行合法的HTTP应答时
  - （1）无法直接从Chrome访问`<ip>:<port>`获取文件，看F12，请求被canceled
  - （2）Windows上`curl <ip>:<port>`也会提示`curl: (1) Received HTTP/0.9 when not allowed`
  - （3）Jerry上`wget <ip>:<port>`能获取成功，显示`...200 No headers, assuming HTTP/0.9`，能把文件拉下来
  - （4）Jerry上`telnet <ip> <port>`能成功显示文件内容
  - 通过**对比telnet和curl和chrome访问的tcpdump结果**发现数据已经传输并被确认，符合（3）、（4），但是telnet时是Tom主动发送FIN，其他三种都是客户端会主动发送FIN然后Tom响应Reset。



#### 代码

- 服务端：`respond_http.cc`
- 客户端：Window上Chrome访问或curl、Ubunut上telnet或wget，`<command> <ip>:<port>`



#### <span style="color:red">思考题</span>

##### Q1：有无内核空间的`writev()`？（jyy：你想到别人肯定想过）



##### Q2：如何知道HTTP报文格式约定？

描述：最容易谷歌出来的是Mozilla HTTP Messages，为什么？mozilla的文档是不是官方的？如何知道行之间的分割符是`\r\n`？

- 官方文档应该是RFC 2616（HTTP/1.1），应该学会查RFC：
  - WEB：https://datatracker.ietf.org/doc
  - PDF：https://www.rfc-editor.org
- RFC 2616的2.2和6，说得简单明了：
  - `2.2`：HTTP/1.1以CRLF作为除entity-body部分的行尾标记
  - `6`：<img src="./img/RFC2616响应头结构.png" style="zoom:60%;" />
- 





### 实验2-用状态机解析HTTP请求

#### 基本

- 尝试状态机写法，维护`报文处理状态机`和`行处理状态机`，但依旧有很多问题
  - 关于**状态转移**：状态转移是否应该集中在一个函数？如果是，保证做到的原则/设计是？比如`报文处理状态机`的result（对一次recv的处理结果）改变，check_stat（对报文所处处理环节）的改变可以比较集中）？
  - 关于**接收缓存**：buf如何复用？`CheckOneLine()`对buf造成了破坏，能不能破坏？能不能不要破坏？
  - 关于**与TCP状态机**的联系：二者有联系吗？如果有，TCP状态机如何体现在这里？
  - **暂用struct代替了class，"全局变量"放入struct，是否有更好方式？**



#### 代码

- 接收端：`handle_http_request.cc`
- 发送端：Chrome/wget/curl。
- telnet会卡住，能不能提示？卡在recv了？



#### <span style="color:red">思考题</span>

##### Q1：把HTTP报文当字符串处理是最好的选择吗？是最直观的选择吗？

描述：Mozilla说

> HTTP messages are composed of textual information encoded in ASCII

但未找到RFC中有相关明确指示（http族的RFC：https://datatracker.ietf.org/group/http/documents/）



##### Q2：局部const生命周期是怎样的？（见`RESULT_CODE ParseReqLine(const char*)`）





##### Q3：`printf`的`%.*s`本质上有没有进行`strncpy()`或`memcpy()`？

描述：尝试用`printf`输出字符串的特定长度时有疑问（https://stackoverflow.com/questions/7780809/is-it-possible-to-print-out-only-a-certain-section-of-a-c-string-without-making）





### 实验3-用poll实现简易群聊

#### 基本

- 对socketfd的`send()`和`recv()`，似乎都可以是默认的设置（即阻塞）。根据`man poll`，`poll()`也是阻塞的，其中NOTES有一句话<span style="color:red">待理解</span>

> The operation of poll() and ppoll() is not affected by the O_NONBLOCK flag.

- `poll()`所用的pollfd集合用数组维护，`元素增减`与`检查poll返回时各pollfd状态的过程`耦合了。而且删除本质为替换，需要在`poll(kFDS, 1 + kCntClient, -1)`中用实际个数限制有效的kFDS长度。否则关闭后的socket依旧会返回（<span style="color:red">有无方式避免？待确认已关闭socketfd此时的revents状态</span>）

  关于poll的返回

> If none of the events requested (and no **error**) has occurred for any of the file descriptors, then poll() blocks until **one of the events occurs**

- 牺牲大量空间换时间：目前用桶哈希维护接入的socketfd到其buffer的映射
  - <span style="color:red">可以尝试STL set吗？</span>
- **尽量不要一次性写超过20行的未测试代码**，这次编码中模块化/阶段性测试帮到我很多



#### 代码

- 服务端：`group_chat_service.cc`
- 客户端：`telnet`（可以尝试自己用poll造一个）



#### <span style="color:red">思考题</span>

##### Q1：结构体复制是值复制还是指针复制？

描述：代码中用到了结构体的赋值，能否避免？（https://stackoverflow.com/questions/2302351/assign-one-struct-to-another-in-c）



##### Q2：为什么监听的socket是SOCK_STREAM，`accept`的socket要设置成non-blocking？



##### Q3：为什么要先处理HUP、ERR，最后处理POLLIN，定义拦截顺序是否合理？能否使独立？

描述：peer_sock关闭后，服务器端的socket似乎会同时触发POLLIN和POLLRDHUP，需要在进入POLLIN前将处理拦截在POLLRDHUP。如果进入了POLLIN进行recv()，会返回0（BLOCKING。NONBLOCK好像不生效？）



##### Q4：书中代码为什么每次都在POLLIN和POLLOUT中修改所有客户socket pollfd的`events`？

